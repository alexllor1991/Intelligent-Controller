/*
 * Copyright (C) 2015 SDN Hub

 Licensed under the GNU GENERAL PUBLIC LICENSE, Version 3.
 You may not use this file except in compliance with this License.
 You may obtain a copy of the License at

    http://www.gnu.org/licenses/gpl-3.0.txt

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied.

 *
 */

package org.sdnhub.odl.tutorial.learningswitch.impl;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opendaylight.controller.md.sal.binding.api.DataBroker;
import org.opendaylight.controller.md.sal.common.api.data.LogicalDatastoreType;
import org.opendaylight.controller.sal.binding.api.NotificationProviderService;
import org.opendaylight.controller.sal.binding.api.RpcProviderRegistry;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.yang.types.rev100924.MacAddress;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.list.Action;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.OutputActionCaseBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.output.action._case.OutputActionBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.list.ActionBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.list.ActionKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowCapableNode;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.Table;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.TableKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table.Flow;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table.FlowBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table.FlowKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.InstructionsBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.MatchBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.instruction.instruction.ApplyActionsCaseBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.instruction.instruction.apply.actions._case.ApplyActionsBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.instruction.list.Instruction;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.instruction.list.InstructionBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.instruction.list.InstructionKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeConnectorId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeConnectorRef;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.node.NodeConnector;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.node.NodeConnectorKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.node.NodeConnectorBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeRef;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.Nodes;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.Node;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketProcessingListener;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketProcessingService;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketReceived;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.TransmitPacketInput;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.TransmitPacketInputBuilder;
import org.opendaylight.yangtools.concepts.Registration;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.sdnhub.odl.tutorial.utils.GenericTransactionUtils;
import org.sdnhub.odl.tutorial.utils.PacketParsingUtils;
import org.sdnhub.odl.tutorial.utils.inventory.InventoryUtils;
import org.sdnhub.odl.tutorial.utils.openflow13.MatchUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev130712.LinkId;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev130712.link.attributes.DestinationBuilder;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.NetworkTopology;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.TopologyId;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.link.attributes.Source;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.link.attributes.SourceBuilder;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.Topology;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.TopologyKey;
//import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.LinkBuilder;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.LinkKey;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.node.TerminationPoint;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.node.TerminationPointBuilder;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.node.TerminationPointKey;
import org.opendaylight.controller.md.sal.common.api.data.LogicalDatastoreType;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.topology.discovery.rev130819.Link;
//import org.opendaylight.openflowplugin.api.openflow.*;
//import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.openflowplugin.api.types.rev150327.OfpRole;
//import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.openflow.common.config.impl.rev140326.OfpRole; //openflow-impl
//import org.opendaylight.openflowplugin.openflow.*;
//import org.opendaylight.openflowplugin.openflow.md.core.sal.OpenflowPluginProvider;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.topology.discovery.rev130819.LinkDiscoveredBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.topology.discovery.rev130819.LinkDiscovered;









import com.rti.dds.domain.DomainParticipant;
import com.rti.dds.domain.DomainParticipantFactory;
import com.rti.dds.infrastructure.RETCODE_ERROR;
import com.rti.dds.infrastructure.RETCODE_NO_DATA;
import com.rti.dds.infrastructure.StatusKind;
import com.rti.dds.subscription.DataReader;
import com.rti.dds.subscription.DataReaderAdapter;
import com.rti.dds.subscription.SampleInfo;
import com.rti.dds.subscription.Subscriber;
import com.rti.dds.topic.Topic;
import com.rti.dds.type.builtin.StringDataReader;
import com.rti.dds.type.builtin.StringTypeSupport;

import org.sdnhub.odl.tutorial.learningswitch.impl.*;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;

public class TutorialL2Forwarding  extends DataReaderAdapter implements AutoCloseable, PacketProcessingListener {
    private final Logger LOG = LoggerFactory.getLogger(this.getClass());
    private final static long FLOOD_PORT_NUMBER = 0xfffffffbL;
    private static long noPacket = 0; // For debugging
    private int index;
    private int vez=0;
    private Map<String, Map<String, String>> macTablePerSwitch = new HashMap <String, Map<String, String>>();
    private static boolean shutdown_flag = false;


    //Members specific to this class
    private Map<String, NodeConnectorId> macTable = new HashMap <String, NodeConnectorId>();
	private String function = "learning";
        
    //Members related to MD-SAL operations
	private List<Registration> registrations;
	private DataBroker dataBroker;
	private PacketProcessingService packetProcessingService;
        private DomainParticipant participant = null;
	private Topic topic = null;
	private Topic topic2 = null;
//	private StringDataReader dataReader2 = null;
	private topologiaDataReader dataReader = null;
//	private OfpRole role;
	
    public TutorialL2Forwarding(DataBroker dataBroker, NotificationProviderService notificationService, RpcProviderRegistry rpcProviderRegistry) {
    	//Store the data broker for reading/writing from inventory store
        this.dataBroker = dataBroker;

        //Get access to the packet processing service for making RPC calls later
        this.packetProcessingService = rpcProviderRegistry.getRpcService(PacketProcessingService.class);        

    	//List used to track notification (both data change and YANG-defined) listener registrations
    	this.registrations = Lists.newArrayList(); 

        //Register this object for receiving notifications when there are PACKET_INs
        registrations.add(notificationService.registerNotificationListener(this));

	//Controller role
//	role=OfpRole.BECOMESLAVE;
//	OpenflowPluginProvider openflowpluginprovider = new OpenflowPluginProvider();
//	openflowpluginprovider.initialization();
//	openflowpluginprovider.setRole(role);

	//Aqui se crea el participante de DDS, el Topic y el DataWriter
	participant = DomainParticipantFactory.get_instance().create_participant(
                0, // Domain ID = 0
                DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT, 
                null, // listener
                StatusKind.STATUS_MASK_NONE);
        if (participant == null) {
            System.err.println("Unable to create domain participant");
            return;
        }

        // Create the topic "Flujos" for the String type
        topic = participant.create_topic(
                "Hello, World", 
                StringTypeSupport.get_type_name(), 
                DomainParticipant.TOPIC_QOS_DEFAULT, 
                null, // listener
                StatusKind.STATUS_MASK_NONE);
        if (topic == null) {
            System.err.println("Unable to create topic.");
            return;
        }
 String typeName = topologiaTypeSupport.get_type_name();
            topologiaTypeSupport.register_type(participant, typeName);
	// Create the topic "Flujos" for the String type
       topic2 = participant.create_topic(
                "topologia", 
                typeName, 
                DomainParticipant.TOPIC_QOS_DEFAULT, 
                null, // listener
                StatusKind.STATUS_MASK_NONE);
        if (topic == null) {
            System.err.println("Unable to create topic.");
            return;
        }
        // Create the data reader using the default subscriber
/*        dataReader2 =
            (StringDataReader) participant.create_datareader(
                topic, 
                Subscriber.DATAREADER_QOS_DEFAULT,
                new TutorialL2Forwarding(),         // Listener
                StatusKind.DATA_AVAILABLE_STATUS);
        if (dataReader2 == null) {
            System.err.println("Unable to create DDS Data Reader");
            return;
        }*/
	dataReader=
            (topologiaDataReader) participant.create_datareader(
                topic2, 
                Subscriber.DATAREADER_QOS_DEFAULT,
                new TutorialL2Forwarding(dataBroker),         // Listener
                StatusKind.DATA_AVAILABLE_STATUS);
        if (dataReader == null) {
            System.err.println("Unable to create DDS Data Reader");
            return;
        }
	
  	}
public TutorialL2Forwarding(DataBroker dataBroker){
	this.dataBroker = dataBroker;
}

    @Override
    public void close() throws Exception {
        for (Registration registration : registrations) {
        	registration.close();
        }
        registrations.clear();
    }

    @Override
	public void onPacketReceived(PacketReceived notification) {
/*	OfpRole role;
	role=OfpRole.BECOMEMASTER;
	OpenflowPluginProvider o;
	o.fireRoleChange(role);*/  //Solucionar el import de esta linea, relacionado con el OfpRole

/*	if(vez==0){
	participant = DomainParticipantFactory.get_instance().create_participant(
                0, // Domain ID = 0
                DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT, 
                null, // listener
                StatusKind.STATUS_MASK_NONE);
        if (participant == null) {
            System.err.println("Unable to create domain participant");
            return;
        }

        // Create the topic "Flujos" for the String type
        topic = participant.create_topic(
                "Hello, World", 
                StringTypeSupport.get_type_name(), 
                DomainParticipant.TOPIC_QOS_DEFAULT, 
                null, // listener
                StatusKind.STATUS_MASK_NONE);
        if (topic == null) {
            System.err.println("Unable to create topic.");
            return;
        }
        // Create the data reader using the default subscriber
        dataReader =
            (StringDataReader) participant.create_datareader(
                topic, 
                Subscriber.DATAREADER_QOS_DEFAULT,
                new TutorialL2Forwarding(),         // Listener
                StatusKind.DATA_AVAILABLE_STATUS);
        if (dataReader == null) {
            System.err.println("Unable to create DDS Data Reader");
            return;
        }
	vez=vez+1;
	}*/
    	LOG.trace("Received packet notification {}", notification.getMatch());

        NodeConnectorRef ingressNodeConnectorRef = notification.getIngress();
        NodeRef ingressNodeRef = InventoryUtils.getNodeRef(ingressNodeConnectorRef);
        NodeConnectorId ingressNodeConnectorId = InventoryUtils.getNodeConnectorId(ingressNodeConnectorRef);
        NodeId ingressNodeId = InventoryUtils.getNodeId(ingressNodeConnectorRef);

        // Useful to create it beforehand 
    	NodeConnectorId floodNodeConnectorId = InventoryUtils.getNodeConnectorId(ingressNodeId, FLOOD_PORT_NUMBER);
    	NodeConnectorRef floodNodeConnectorRef = InventoryUtils.getNodeConnectorRef(floodNodeConnectorId);

        /*
         * Logic:
         * 0. Ignore LLDP packets
         * 1. If behaving as "hub", perform a PACKET_OUT with FLOOD action
         * 2. Else if behaving as "learning switch",
         *    2.1. Extract MAC addresses
         *    2.2. Update MAC table with source MAC address
         *    2.3. Lookup in MAC table for the target node connector of dst_mac
         *         2.3.1 If found, 
         *               2.3.1.1 perform FLOW_MOD for that dst_mac through the target node connector
         *               2.3.1.2 perform PACKET_OUT of this packet to target node connector
         *         2.3.2 If not found, perform a PACKET_OUT with FLOOD action
         */

    	//Ignore LLDP packets, or you will be in big trouble
        byte[] etherTypeRaw = PacketParsingUtils.extractEtherType(notification.getPayload());
        int etherType = (0x0000ffff & ByteBuffer.wrap(etherTypeRaw).getShort());
        if (etherType == 0x88cc) {
        	return;
        }
        
        // Hub implementation
        if (function.equals("hub")) {
        	
        	//flood packet (1)
            packetOut(ingressNodeRef, floodNodeConnectorRef, notification.getPayload());
        } else {
        	noPacket = noPacket + 1;

            byte[] payload = notification.getPayload();
            byte[] dstMacRaw = PacketParsingUtils.extractDstMac(payload);
            byte[] srcMacRaw = PacketParsingUtils.extractSrcMac(payload);

            //Extract MAC addresses (2.1)
            String srcMac = PacketParsingUtils.rawMacToString(srcMacRaw);
            String dstMac = PacketParsingUtils.rawMacToString(dstMacRaw);

            //Strings for ingressNodeId and ingressNodeConnectorId
            String ingressNodeIdStr = ingressNodeId.getValue();
            String ingressNodeConnectorIdStr = ingressNodeConnectorId.getValue();

            //Create a table for this switch if it does not exist
            if(!this.macTablePerSwitch.containsKey(ingressNodeIdStr)) {
            	//LOG.debug("JNa>> noPacket {}, switch:port {} -> Creating MAC table for this switch in the controller", noPacket, ingressNodeConnectorIdStr, ingressNodeIdStr);
            	this.macTablePerSwitch.put(ingressNodeIdStr, new HashMap<String, String>());
            }

            //Learn source MAC address (2.2)
            String previousSrcMacPortStr = this.macTablePerSwitch.get(ingressNodeIdStr).get(srcMac);
            if ((previousSrcMacPortStr == null) || (!ingressNodeConnectorIdStr.equals(previousSrcMacPortStr)))
            {
                this.macTablePerSwitch.get(ingressNodeIdStr).put(srcMac, ingressNodeConnectorIdStr);
                //programL2Flow(ingressNodeId, srcMac, null, ingressNodeConnectorId);
            } else {}

            //Lookup destination MAC address in table (2.3)
            String egressNodeConnectorIdStr = this.macTablePerSwitch.get(ingressNodeIdStr).get(dstMac);
            NodeConnectorId egressNodeConnectorId = null;
            NodeConnectorRef egressNodeConnectorRef = null;
            if (egressNodeConnectorIdStr != null) {
            	//Entry found (2.3.1)
           		egressNodeConnectorId = new NodeConnectorId(egressNodeConnectorIdStr);
           		egressNodeConnectorRef = InventoryUtils.getNodeConnectorRef(egressNodeConnectorId);

                //Perform FLOW_MOD (2.3.1.1)
                programL2Flow(ingressNodeId, dstMac, ingressNodeConnectorId, egressNodeConnectorId);

                //Perform PACKET_OUT (2.3.1.2)
                packetOut(ingressNodeRef, egressNodeConnectorRef, payload);
            } else {
            	//Flood packet (2.3.2)
            	floodingPacket(ingressNodeConnectorRef, payload);            // FLOODING packets to each port for any topology

 	    //Añadir aqui la parte para transferir los flujos con DDS
	    //TOPOLOGY
	    InstanceIdentifier<NetworkTopology> ntII = InstanceIdentifier.builder(NetworkTopology.class).build();
            NetworkTopology networkTopology = GenericTransactionUtils.readData(dataBroker, LogicalDatastoreType.OPERATIONAL, ntII);
            LOG.debug("JNa>> networkTopology = {}", networkTopology);
	    //System.out.println(networkTopology.toString());
            
            // Topology
            List<Topology> topologies = networkTopology.getTopology();
            //for (Topology topo : topologies) {
            // Only the first topology is defined by default in ODL
            Topology topo = topologies.get(0);
            LOG.debug("JNa>> topo = {}", topo);
	    System.out.println(topo.toString());
		List<org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Node> nodes = topo.getNode();
            LOG.debug("JNa>> nodes = {}", nodes);

           index = 0;
            for (org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Node node : nodes) {
            	System.out.println(node.getNodeId().getValue().toString());
            	index = index + 1;
            	List<TerminationPoint> TP = node.getTerminationPoint();
            	for(TerminationPoint Tp : TP){
			System.out.println(Tp.getTpId().getValue().toString());
		}
            }
/*		 List<org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link> links = topo.getLink();

            index = 0;
            for (org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link link : links) {
		System.out.println(link.getLinkId().getValue());
		System.out.println(link.getSource().getSourceNode().getValue().toString());
		System.out.println(link.getSource().getSourceTp().getValue().toString());
		System.out.println(link.getDestination().getDestNode().getValue().toString());
		System.out.println(link.getDestination().getDestTp().getValue().toString());
            	index = index + 1;
            }
		System.out.println(index);
*/
	}
        }
    }

 public void on_data_available(DataReader reader) {
        topologiaDataReader topologiaReader = (topologiaDataReader) reader;
        SampleInfo info = new SampleInfo();
	topologia sample = new topologia();
        for (;;) {
            try {
                topologiaReader.take_next_sample(sample,info);
                    System.out.println(sample);

		    if(sample.Identificador.equals("Node")){

			NodeBuilder node = new NodeBuilder();
			NodeId nodeId = new NodeId(sample.NodeId);
			node.setId(nodeId);
        		NodeKey key = new NodeKey(new NodeId(nodeId));
			node.setKey(key);

			InstanceIdentifier<Node> instanceIdentifier = InstanceIdentifier.builder(Nodes.class)
			.child(Node.class, new NodeKey(nodeId)).build();
        		GenericTransactionUtils.writeData(dataBroker, LogicalDatastoreType.OPERATIONAL, instanceIdentifier,node.build(),true);
			System.out.println("Nodo introducido en la base de datos");
		    }
		    if(sample.Identificador.equals("TerminationPoint")){

			System.out.println("TerminationPoint introducido en la base de datos");
			NodeConnectorBuilder nodeConnector = new NodeConnectorBuilder();
			NodeConnectorId nodeConnectorId = new NodeConnectorId(sample.TerminationPointId);
			NodeConnectorKey key = new NodeConnectorKey(new NodeConnectorId(nodeConnectorId));
			nodeConnector.setId(nodeConnectorId);
			nodeConnector.setKey(key);

			InstanceIdentifier<NodeConnector> instanceIdentifier2 = InstanceIdentifier.builder(Nodes.class)
                        .child(Node.class, new NodeKey(new NodeId(sample.NodeId)))
		        .child(NodeConnector.class, new NodeConnectorKey(new NodeConnectorId(sample.TerminationPointId)))
		        .build();
        		GenericTransactionUtils.writeData(dataBroker, LogicalDatastoreType.OPERATIONAL, instanceIdentifier2,nodeConnector.build(),true);
			System.out.println("TerminationPoint introducido en la base de datos");
		    }
		    if(sample.Identificador.equals("Link")){
			System.out.println("Partes del link recibidas");
			
			NodeId localNodeId = new NodeId(sample.SourceNode);
			NodeConnectorId localNodeConnectorId = new NodeConnectorId(sample.SourceNodeTp);
			NodeId remoteNodeId = new NodeId(sample.DestinationNode);
			NodeConnectorId remoteNodeConnectorId = new NodeConnectorId(sample.DestinationNodeTp);
			
//			LinkBuilder link = new LinkBuilder();
//			org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.LinkId linkId = new org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.LinkId(sample.LinkId);
//			LinkKey linkkey = new LinkKey(linkId);
//			link.setLinkId(linkId);
//			link.setKey(linkkey);
//			SourceBuilder source = new SourceBuilder();
//			source.setSourceNode(localNodeId);
//			source.setSourceTp(localNodeConnectorId);
//			DestinationBuilder destination = new DestinationBuilder();
//			destination.setDestNode(remoteNodeId);
//			destination.setDestTp(remoteNodeConnectorId);
//			link.setSource(source);
//			link.setDestination(destination);


			InstanceIdentifier<NodeConnector> localInstanceIdentifier = InstanceIdentifier.builder(Nodes.class)
                		.child(Node.class, new NodeKey(localNodeId))
                		.child(NodeConnector.class, new NodeConnectorKey(localNodeConnectorId)).toInstance();
			NodeConnectorRef localNodeConnectorRef = new NodeConnectorRef(localInstanceIdentifier);
			
			InstanceIdentifier<NodeConnector> remoteInstanceIdentifier = InstanceIdentifier.builder(Nodes.class)
                	.child(Node.class, new NodeKey(remoteNodeId))
                	.child(NodeConnector.class, new NodeConnectorKey(remoteNodeConnectorId)).toInstance();
			NodeConnectorRef remoteNodeConnectorRef = new NodeConnectorRef(remoteInstanceIdentifier);
//			InstanceIdentifier<LinkDiscovered> InstanceIdentifier = InstanceIdentifier.builder(Lin.class).toInstance();
			//Falta crear el link y meterlo en la base de datos
			LinkDiscoveredBuilder ldb = new LinkDiscoveredBuilder();
			ldb.setSource(localNodeConnectorRef);
			ldb.setDestination(remoteNodeConnectorRef);
//			GenericTransactionUtils.writeData(dataBroker, LogicalDatastoreType.OPERATIONAL, instanceIdentifier2,ldb.build(),true);
			}
			if(sample.Identificador.equals("Flow")){
				System.out.println("Flujo recibido");
				NodeId nodeId = new NodeId(sample.NodeId);
				String srcMac = sample.SourceNode;
				String dstMac = sample.DestinationNode;
				NodeConnectorId  ingressNodeConnectorId = new NodeConnectorId(sample.SourceNodeTp);

				//Create a table for this switch if it does not exist
            			if(!this.macTablePerSwitch.containsKey(sample.NodeId)) {
            				this.macTablePerSwitch.put(sample.NodeId, new HashMap<String, String>());
            			}

            			//Learn source MAC address (2.2)
            			String previousSrcMacPortStr = this.macTablePerSwitch.get(sample.NodeId).get(srcMac);
            			if ((previousSrcMacPortStr == null) || (!sample.SourceNodeTp.equals(previousSrcMacPortStr)))
            			{
                			this.macTablePerSwitch.get(sample.NodeId).put(srcMac, sample.SourceNodeTp);
            			} else {}

				String egressNodeConnectorIdStr = this.macTablePerSwitch.get(sample.NodeId).get(dstMac);
				NodeConnectorId  egressNodeConnectorId = null;
				if (egressNodeConnectorIdStr != null) {
					System.out.println("Flujo instalado");
            			//Entry found (2.3.1)
           				egressNodeConnectorId = new NodeConnectorId(egressNodeConnectorIdStr);
           		       //Perform FLOW_MOD (2.3.1.1)
                			programL2Flow(nodeId, dstMac, ingressNodeConnectorId, egressNodeConnectorId);
					System.out.println("Flujo instalado");
				}
			}

                    if (sample.equals("")) {
                        shutdown_flag = true;
                    }
            } catch (RETCODE_NO_DATA noData) {
                // No more data to read
                break;
            } catch (RETCODE_ERROR e) {
                // An error occurred
                e.printStackTrace();
            }
        }
    }

private void floodingPacket(NodeConnectorRef ingressNodeConnectorRef, byte[] payload) {
    	LOG.debug("ENTERING floodingPacket");
    	NodeRef ingressNodeRef = InventoryUtils.getNodeRef(ingressNodeConnectorRef);
        NodeConnectorId ingressNodeConnectorId = InventoryUtils.getNodeConnectorId(ingressNodeConnectorRef);
        NodeId ingressNodeId = InventoryUtils.getNodeId(ingressNodeConnectorRef);
        String ingressNodeConnectorIdStr = ingressNodeConnectorId.getValue();
        NodeKey ingressNodeKey = new NodeKey(ingressNodeId);

        InstanceIdentifier<Node> nodeIdentifier = InstanceIdentifier.builder(Nodes.class).
                                                        child(Node.class,ingressNodeKey).toInstance();
        Node ingressNode = GenericTransactionUtils.readData(dataBroker, LogicalDatastoreType.OPERATIONAL, nodeIdentifier);

        if (ingressNode != null) {
	        List<NodeConnector> nodeConnectorList = ingressNode.getNodeConnector();
	        LOG.debug(" SWITCH with {} connectors in floodingPacket", nodeConnectorList.size());
	
	        for (NodeConnector nodeConnector : nodeConnectorList) {
	        	NodeConnectorId nodeConnectorId = nodeConnector.getId();
	        	String nodeConnectorIdStr = nodeConnectorId.getValue();
	        	NodeConnectorRef nodeConnectorRef = InventoryUtils.getNodeConnectorRef(nodeConnectorId);
	        	LOG.debug(" TESTING connector {} in floodingPacket", nodeConnectorIdStr);
	
	        	if (!nodeConnectorIdStr.equals(ingressNodeConnectorIdStr) && !nodeConnectorIdStr.contains("LOCAL")) {
	        		LOG.debug(" FLOODING port by port, sent to port {}", nodeConnectorIdStr);
	        		packetOut(ingressNodeRef, nodeConnectorRef, payload);
	        	}
	        }
        }
    }

	private void packetOut(NodeRef egressNodeRef, NodeConnectorRef egressNodeConnectorRef, byte[] payload) {
        Preconditions.checkNotNull(packetProcessingService);
        LOG.debug("Flooding packet of size {} out of port {}", payload.length, egressNodeConnectorRef);

        //Construct input for RPC call to packet processing service
        TransmitPacketInput input = new TransmitPacketInputBuilder()
                .setPayload(payload)
                .setNode(egressNodeRef)
                .setEgress(egressNodeConnectorRef)
                .build();
        packetProcessingService.transmitPacket(input);       
    }    
	
    private void programL2Flow(NodeId nodeId, String dstMac, NodeConnectorId ingressNodeConnectorId, NodeConnectorId egressNodeConnectorId) {

    	/* Programming a flow involves:
    	 * 1. Creating a Flow object that has a match and a list of instructions,
    	 * 2. Adding Flow object as an augmentation to the Node object in the inventory.
    	 * 3. FlowProgrammer module of OpenFlowPlugin will pick up this data change and eventually program the switch.
    	 */

        //Creating match object
        MatchBuilder matchBuilder = new MatchBuilder();
        MatchUtils.createEthDstMatch(matchBuilder, new MacAddress(dstMac), null);
//        MatchUtils.createInPortMatch(matchBuilder, ingressNodeConnectorId);

        // Instructions List Stores Individual Instructions
        InstructionsBuilder isb = new InstructionsBuilder();
        List<Instruction> instructions = Lists.newArrayList();
        InstructionBuilder ib = new InstructionBuilder();
        ApplyActionsBuilder aab = new ApplyActionsBuilder();
        ActionBuilder ab = new ActionBuilder();
        List<Action> actionList = Lists.newArrayList();

        // Set output action
        OutputActionBuilder output = new OutputActionBuilder();
        output.setOutputNodeConnector(egressNodeConnectorId);
        output.setMaxLength(65535); //Send full packet and No buffer
        ab.setAction(new OutputActionCaseBuilder().setOutputAction(output.build()).build());
        ab.setOrder(0);
        ab.setKey(new ActionKey(0));
        actionList.add(ab.build());

        // Create Apply Actions Instruction
        aab.setAction(actionList);
        ib.setInstruction(new ApplyActionsCaseBuilder().setApplyActions(aab.build()).build());
        ib.setOrder(0);
        ib.setKey(new InstructionKey(0));
        instructions.add(ib.build());

        // Create Flow
        FlowBuilder flowBuilder = new FlowBuilder();
        flowBuilder.setMatch(matchBuilder.build());

        String flowId = "L2_Rule_" + dstMac;
        flowBuilder.setId(new FlowId(flowId));
        FlowKey key = new FlowKey(new FlowId(flowId));
        flowBuilder.setBarrier(true);
        flowBuilder.setTableId((short)0);
        flowBuilder.setKey(key);
        flowBuilder.setPriority(32768);
        flowBuilder.setFlowName(flowId);
        flowBuilder.setHardTimeout(0);
        flowBuilder.setIdleTimeout(0);
        flowBuilder.setInstructions(isb.setInstruction(instructions).build());

        InstanceIdentifier<Flow> flowIID = InstanceIdentifier.builder(Nodes.class)
                .child(Node.class, new NodeKey(nodeId))
                .augmentation(FlowCapableNode.class)
                .child(Table.class, new TableKey(flowBuilder.getTableId()))
                .child(Flow.class, flowBuilder.getKey())
                .build();
        GenericTransactionUtils.writeData(dataBroker, LogicalDatastoreType.CONFIGURATION, flowIID, flowBuilder.build(), true);


    }
private void programL2FlowOperational(NodeId nodeId, String dstMac, NodeConnectorId ingressNodeConnectorId, NodeConnectorId egressNodeConnectorId) {

    	/* Programming a flow involves:
    	 * 1. Creating a Flow object that has a match and a list of instructions,
    	 * 2. Adding Flow object as an augmentation to the Node object in the inventory.
    	 * 3. FlowProgrammer module of OpenFlowPlugin will pick up this data change and eventually program the switch.
    	 */

        //Creating match object
        MatchBuilder matchBuilder = new MatchBuilder();
        MatchUtils.createEthDstMatch(matchBuilder, new MacAddress(dstMac), null);
//        MatchUtils.createInPortMatch(matchBuilder, ingressNodeConnectorId);

        // Instructions List Stores Individual Instructions
        InstructionsBuilder isb = new InstructionsBuilder();
        List<Instruction> instructions = Lists.newArrayList();
        InstructionBuilder ib = new InstructionBuilder();
        ApplyActionsBuilder aab = new ApplyActionsBuilder();
        ActionBuilder ab = new ActionBuilder();
        List<Action> actionList = Lists.newArrayList();

        // Set output action
        OutputActionBuilder output = new OutputActionBuilder();
        output.setOutputNodeConnector(egressNodeConnectorId);
        output.setMaxLength(65535); //Send full packet and No buffer
        ab.setAction(new OutputActionCaseBuilder().setOutputAction(output.build()).build());
        ab.setOrder(0);
        ab.setKey(new ActionKey(0));
        actionList.add(ab.build());

        // Create Apply Actions Instruction
        aab.setAction(actionList);
        ib.setInstruction(new ApplyActionsCaseBuilder().setApplyActions(aab.build()).build());
        ib.setOrder(0);
        ib.setKey(new InstructionKey(0));
        instructions.add(ib.build());

        // Create Flow
        FlowBuilder flowBuilder = new FlowBuilder();
        flowBuilder.setMatch(matchBuilder.build());

        String flowId = "L2_Rule_" + dstMac;
        flowBuilder.setId(new FlowId(flowId));
        FlowKey key = new FlowKey(new FlowId(flowId));
        flowBuilder.setBarrier(true);
        flowBuilder.setTableId((short)0);
        flowBuilder.setKey(key);
        flowBuilder.setPriority(32768);
        flowBuilder.setFlowName(flowId);
        flowBuilder.setHardTimeout(0);
        flowBuilder.setIdleTimeout(0);
        flowBuilder.setInstructions(isb.setInstruction(instructions).build());

        InstanceIdentifier<Flow> flowIID = InstanceIdentifier.builder(Nodes.class)
                .child(Node.class, new NodeKey(nodeId))
                .augmentation(FlowCapableNode.class)
                .child(Table.class, new TableKey(flowBuilder.getTableId()))
                .child(Flow.class, flowBuilder.getKey())
                .build();
        GenericTransactionUtils.writeData(dataBroker, LogicalDatastoreType.OPERATIONAL, flowIID, flowBuilder.build(), true);


    }
}
